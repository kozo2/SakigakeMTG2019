---
title: "Exercise1: Rの基本操作"
output: html_notebook
---

このノートブックでは、Rの基本的な使い方について説明します

## データ型
---

あらゆるプログラミング言語において、データには型があります

例えば、Rのコンソール画面で1と打つと1と出力されますが

```{r}
1
```

isという関数を使うと、これは"numeric"という型を持ち、また長さ1のvector（後述）でもあることがわかります

```{r}
is(1)
```

整数ではなく、小数点以下の数字も含んだ値（不動小数点数）もnumericです

```{r}
is(2.1)
```

ただし1Lと打つと、これはinteger（整数）としての1を定義したことになります

```{r}
is(1L)
```

数値データは様々な計算ができます

```{r}
1 + 1 # 足し算
```

```{r}
3 - 1 # 引き算
```

```{r}
6 * 2 # 掛け算
```

```{r}
4 / 2 # 割り算
```

```{r}
2^5 # 2の5乗
```

```{r}
log10(5) # 5の常用対数値
```

ダブルクオーテーション"で文字列をくくると、これはcharacterというデータ型になります

```{r}
"SAKIGAKE"
```

```{r}
is("SAKIGAKE")
```

```{r}
is(1) # 1は数値
```

```{r}
is("1") # ""で囲むと文字列
```

numericとcharacter同士は計算することができません

ただし例外的に、paste関数では文字列も数値も扱えます

このようにデータの型の違いによって、関数の挙動が異なるので、注意が必要です

```{r}
try(1 + "1") # 数値と文字列を足すことはできない
```

```{r}
paste0("SAKIGAKE", "5") # 文字列同士を連結することはできる
```

```{r}
paste0("SAKIGAKE", 5) # paste0関数の仕様で、文字列と数値を連結することはできる
```

論理値TRUE/FALSEはlogicalというデータ型になります

```{r}
TRUE
```

```{r}
is(TRUE)
```

```{r}
FALSE
```

```{r}
is(FALSE)
```

数値や文字列が等しい（==）場合、TRUEを返します


```{r}
1 == 1 # これはTRUE（==は同じという意味）
```

逆に等しくない場合はFALSEを返します

```{r}
1 == 2 # これはFALSE
```

```{r}
"SAKIGAKE" == "SAKIGAKE" # これはTRUE
```

```{r}
"SAKIGAKE" == "CREST" # これはFALSE
```

!=（等しく無い）と書く事でTRUE/FALSEを反転させた結果を得ることができます

```{r}
"SAKIGAKE" != "CREST" # これはTRUE（!=は違うという意味）
```

最後に、factor（因子）というデータ型を説明します

これは、以下のように同じ値が複数回出てくるベクトル（後述）の表現としてよく使われます

```{r}
JST <- factor(c("SAKIGAKE", "SAKIGAKE",
	"CREST", "CREST", "CREST",
	"ACT-X", "ACT-X", "ACT-X"))
```

nlevels関数で、3種類の値が含まれていることがわかります

```{r}
nlevels(JST) # 3つある
```

その三種類の値は具体的に以下のようなものだとわかります

```{r}
levels(JST) # SAKIGAKE, CREST, ACT-Xがある
```

因子を使う上で注意する必要がある点は、as.numericで数値になってしまう点です

文字列が数値化された場合と異なり、ただの通し番号1,2,3...として数値化されるので注意したいです

```{r}
as.numeric("123456")
```

```{r}
as.character(JST) # 因子を文字列に変換する
```

```{r}
as.numeric(JST) # 因子が数値になる？（よくバグの原因になる）
```

## データ構造
---

### ベクトル

データには構造があります

例えば、Rでは1は長さ1のベクトルとして表現されます


```{r}
# スカラは長さ1のベクトル
is(1)
```


ベクトルを定義して、値を後で参照することができます


```{r}
# c()でベクトルを作成
A <- c(2, 3, 1)
B <- c(-2, 1, -2)
```


```{r}
# 各要素へのアクセス, Rは1-origin
A[1]
```


```{r}
A[2]
```

```{r}
A[3]
```

```{r}
A[4] # 要素にないとNAになる
```

ベクトルに対して、以下のように各種関数が既に用意されています


```{r}
# 最大値、最小値、平均値、中央値
max(A)
min(A)
mean(B)
median(B)
```

```{r}
# 要素ごとの掛け算（他の言語と違うところ）
A * B
```

```{r}
# ベクトル同士の内積
A %*% B
```

文字列でもベクトルを作れます

```{r}
# 文字例でもベクトル
C <- c("A", "B", "C", "A", "AA")
```

```{r}
# Aがどこの場所にあるか
which(C == "A")
```

```{r}
# lengthと組み合わせて使うことが多い
length(which(C == "A"))
```

### 行列

同じ型のデータが二次元に配置された行列というデータ構造もあります


```{r}
# matrix()で行列を作成
E <- matrix(runif(6), nrow=2, ncol=3)
```

```{r}
E[1,]
```

```{r}
E[,2]
```

行列独自の関数が各種用意されています


```{r}
# 行数、列数
nrow(E)
ncol(E)
dim(E)
```

```{r}
# cbind、rbind
cbind(A, B)
rbind(E, A, B)
```

```{r}
# 行レベルでの和、列レベルでの和・平均値
rowSums(E)
colSums(E)
rowMeans(E)
colMeans(E)
```

### データフレーム

matrixは同じ型のデータだけが含まれている必要がありますが、データフレームを使えば、列ごとに違うデータ型を扱うことができます

例えば、irisデータでは、1-4列目はnumeric、5列目はcharacterのデータを含んでいます


```{r}
# 行列は一つの型しか扱えない
# 複数の型（数値、文字、TRUE/FALSE、因子など）を扱いたいときはデータフレーム
data(iris)
head(iris)
```

```{r}
iris$Petal.Length # $で各列にアクセスできる
```

### リスト

データフレームでは、長さがそろった異なるデータ型を列で連結しているイメージですが、型だけでなく長さもばらばらのようなデータに対してはリストを使います


```{r}
# 行列で表現できないようなデータもリストで表現できる
G <- list(X = c(1,2,3),
    Y = matrix(runif(9), nrow=3),
    Z = TRUE)
```

```{r}
G$X # $で各要素にアクセスできる
```

```{r}
G$Y
```

```{r}
G$Z
```

# 配列

3次元以上の配列はarrayという関数で扱うことができます


```{r}
# 普段はあまり使わないが、3次元以上の行列（例: テンソル）を表現する時などに
H <- array(1:10, dim=c(1,2,3))
H[1,1,3]
```

### その他

複雑なデータ構造はstr関数で見るとわかりやすいです


```{r}
str(G)
str(iris)
```

Rの各種関数が返す値は、実は上記のようなこれ以上分解できない（Atomicな）データ型を組み合わせただけにすぎません


```{r}
x <- runif(10)
y <- runif(10)
lr <- lm(y ~ x)
str(lr)
```

```{r}
lr$coefficients
```

## 基本文法
---

### 条件分岐

if-else構文で値によって、実行を切り替えることができます


```{r}
SAKIGAKE <- "SAKIGAKE"
CREST <- "CREST"
if(SAKIGAKE == CREST){
    print("Same!!!")
}else{
    print("Different...")
}
```

### 繰り返し

forやwhile構文で、設定した回数だけ繰り返し処理を行うことができます


```{r}
I <- 1:20
for(i in 1:length(I)){
    print(I[i])
}
```

```{r}
j <- 1
while(j <= 20){
    print(I[j])
    j <- j + 1
}
```

### 関数定義

何度も使う機能は関数として定義しておくと、再利用しやすくなります


```{r}
jijou <- function(x){
    if(is.numeric(x)){
        x^2
    }else{
        stop("x is not numeric!!!")
    }
}
jijou(3)
```

```{r}
try(jijou("3"))
```

### apply

forやwhileよりも、より抽象的な書き方で[applyファミリー関数](https://stats.biopapyrus.jp/r/basic/apply.html)があります


```{r}
apply(matrix(1:12, nrow=3), 1, mean)
```

```{r}
apply(matrix(1:12, nrow=3), 2, var)
```

```{r}
sapply(-3:3, abs)
```

```{r}
lapply(list(A=1:3, B=matrix(1:12, nrow=3)), print)
```

applyに2つのパラメーターを指定したい

```{r}
y <- "SAKIGAKE"
sapply(1:5, function(x, y){
    cat(paste0(y, x, "\n"))
}, y=y)
```

### ディレクトリ操作


```{r}
(d <- getwd()) # ()内の実行と、結果の出力を同時に行う
setwd("../") # 一つ上のディレクトリに移動
getwd()
```

```{r}
setwd(d) # 元いたところに戻る
getwd()
```

### ファイル操作


```{r}
# TSVのI/O
write.table(iris, "iris.txt")
iris.tsv <- read.table("iris.txt")
```

```{r}
# CSVのI/O
write.csv(iris, "iris.csv")
iris.csv <- read.csv("iris.csv")
```

```{r}
# 全オブジェクトのI/O
save.image("20160806_SAKIGAKE.RData")
load("20160806_SAKIGAKE.RData")
```

### システム関数


```{r}
system("ls", intern=TRUE)  # UNIXコマンドをRから呼び出す
```

```{r}
system("whoami", intern=TRUE)  # ユーザー名
```

```{r}
system("pwd", intern=TRUE)  # getwd()と同じ
```

```{r}
system("Rscript --version", intern=TRUE)  # Rscriptのバージョン
```

```{r}
system("rm -rf iris*", intern=TRUE)  # irisから始めるファイルは削除
```

```{r}
sessionInfo()
```
